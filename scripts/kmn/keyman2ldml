#!/usr/bin/python

import argparse, codecs, unicodedata, re
from palaso.kmn.parser import Parser, mapkey, Token, DeadKey, VKey, keyrowmap
from xml.etree import ElementTree as et
from xml.etree import ElementPath as ep
from pprint import pformat
import json

_elementprotect = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;' }
_attribprotect = dict(_elementprotect)
_attribprotect['"'] = '&quot;'

class ETWriter(object):
    """ General purpose ElementTree pretty printer complete with options for attribute order
        beyond simple sorting, and which elements should use cdata """

    nscount = 0
    indent = "\t"

    def __init__(self, et, namespaces = None, attributeOrder = {}, takesCData = set(), elementOrder = []):
        self.root = et
        if namespaces is None: namespaces = {}
        self.namespaces = namespaces
        self.attributeOrder = attributeOrder
        self.maxAts = max([0] + attributeOrder.values()) + 1
        self.elementOrder = dict((x, i+1) for i,x in enumerate(elementOrder))
        self.maxTags = len(self.elementOrder) + 1
        self.takesCData = takesCData

    def _localisens(self, tag):
        if tag[0] == '{':
            ns, localname = tag[1:].split('}', 1)
            qname = self.namespaces.get(ns, '')
            if qname:
                return ('{}:{}'.format(qname, localname), qname, ns)
            else:
                self.nscount += 1
                return (localname, 'ns_' + str(self.nscount), ns)
        else:
            return (tag, None, None)

    def _protect(self, txt, base=_attribprotect):
        return re.sub(ur'['+ur"".join(base.keys())+ur"]", lambda m: base[m.group(0)], txt)

    def _nsprotectattribs(self, attribs, localattribs, namespaces):
        if attribs is not None:
            for k, v in attribs.items():
                (lt, lq, lns) = self._localisens(k)
                if lns and lns not in namespaces:
                    namespaces[lns] = lq
                    localattribs['xmlns:'+lq] = lns
                localattribs[lt] = v
        
    def _sortedattrs(self, n, attribs=None):
        def getorder(x):
            return self.attributeOrder.get(x, self.maxAts)
        def cmpat(x, y):
            return cmp(getorder(x), getorder(y)) or cmp(x, y)
        if attribs != None :
            return sorted(attribs, cmp=cmpat)
        else:
            return sorted(n.keys(), cmp=cmpat)

    def serialize_xml(self, write, base = None, indent = '', topns = True, namespaces = {}, doctype=""):
        """Output the object using write() in a normalised way:
                topns if set puts all namespaces in root element else put them as low as possible"""
        if base is None:
            base = self.root
            write('<?xml version="1.0" encoding="utf-8"?>\n')
            if doctype != "":
                write(doctype+"\n")
        (tag, q, ns) = self._localisens(base.tag)
        localattribs = {}
        if ns and ns not in namespaces:
            namespaces[ns] = q
            localattribs['xmlns:'+q] = ns
        if topns:
            if base == self.root:
                for n,q in self.namespaces.items():
                    localattribs['xmlns:'+q] = n
                    namespaces[n] = q
        else:
            for c in base:
                (lt, lq, lns) = self._localisens(c.tag)
                if lns and lns not in namespaces:
                    namespaces[lns] = q
                    localattribs['xmlns:'+lq] = lns
        self._nsprotectattribs(getattr(base, 'attrib', None), localattribs, namespaces)
        for c in getattr(base, 'comments', []):
            write(u'{}<!--{}-->\n'.format(indent, c))
        write(u'{}<{}'.format(indent, tag))
        if len(localattribs):
            def getorder(x):
                return self.attributeOrder.get(tag, {}).get(x, self.maxAts)
            def cmpattrib(x, y):
                return cmp(getorder(x), getorder(y)) or cmp(x, y)
            for k in self._sortedattrs(base, localattribs):
                write(u' {}="{}"'.format(self._localisens(k)[0], self._protect(localattribs[k])))
        if len(base):
            write('>\n')
            for b in sorted(base, key=lambda b:self.elementOrder.get(b.tag, self.maxTags)):
                self.serialize_xml(write, base=b, indent=indent + self.indent, topns=topns, namespaces=namespaces.copy())
            write('{}</{}>\n'.format(indent, tag))
        elif base.text:
            if tag not in self.takesCData:
                t = self._protect(base.text.replace('\n', '\n' + indent), base=_elementprotect)
            else:
                t = "<![CDATA[\n\t" + indent + base.text.replace('\n', '\n\t' + indent) + "\n" + indent + "]]>"
            write(u'>{}</{}>\n'.format(t, tag))
        else:
            write('/>\n')
        for c in getattr(base, 'commentsafter', []):
            write(u'{}<!--{}-->\n'.format(indent, c))

attributeorders = ('before', 'from', 'after', 'iso', 'to', 'layer', 'display')
#elementOrder = ('version', 'names', 'settings', 'import', 'keyMap', 'displayMap', 'layer', 'vkeys',
#                'transforms', 'reorders', 'backspaces')

class LDMLKeyboard(ETWriter):
    def __init__(self, locale):
        doc = et.fromstring("""<?xml version="1.0"?>
<keyboard locale="{}">
<version platform="1" number="1"/>
<import path="langs/e/en/en-us-win/en-us-win.xml"/>
</keyboard>
""".format(locale))
        let = et.ElementTree()
        let._setroot(doc)
        ETWriter.__init__(self, doc, attributeOrder=dict((x, i+1) for i,x in enumerate(attributeorders)))

    def setname(self, name):
        nms = et.SubElement(self.root, "names")
        et.SubElement(nms, "name", {"value": name})

    def addKeyMap(self, keymap, modifiers):
        km = et.SubElement(self.root, "keyMap", attrib={'modifiers' : modifiers})
        for k, v in sorted(keymap.items()):
            a = {"iso": k, "to": readable(v)}
            if getattr(v, 'error', False):
                a['error'] = "fail"
            et.SubElement(km, "map", attrib=a)

    def mapKey(self, key, modifiers):
        k = self.root.find('.//keyMap[@modifiers="'+modifiers+'"]/map[@iso="'+key+'"]')
        if k is None and (modifiers == '' or modifiers == 'shift'):
            try:
                to = keyrowmap[("_" if modifiers == 'shift' else '')+key[0]][int(key[1:])-1]
            except:
                to = ''
        else:
            to = k.get('to', '') if k is not None else ''
        return to

    def addKey(self, modifiers, key, to):
        k = self.root.find('.//keyMap[@modifiers="'+modifiers+'"]')
        if k is None:
            k = et.SubElement(self.root, "keyMap", attrib={'modifiers': modifiers})
        return et.SubElement(k, 'map', attrib={'iso': key, 'to': to})

    def keyAddAttrs(self, modifiers, key, attrs):
        k = self.root.find('.//keyMap[@modifiers="'+modifiers+'"]/map[@iso="'+key+'"]')
        if k is None:
            k = self.addKey(modifiers, key, self.mapKey(key, modifiers))
        k.attrib.update(attrs)

    def addDisplay(self, to, display):
        k = self.root.find(".//displayMap")
        if k is None:
            k = et.SubElement(self.root, "displayMap")
        pto = (u'"{}"' if '"' not in to else u"'{}'").format(to)
        pdisplay = (u'"{}"' if '"' not in display else u"'{}'").format(display)
        if self.root.find('.//displayMap/display[@mapOutput='+pto+']') is None:
            et.SubElement(k, "display", attrib={'mapOutput': to, 'display': display})

    def addTransform(self, t, rules, keyword="transform"):
        if t == keyword:
            ts = et.SubElement(self.root, keyword+"s")
        else:
            ts = et.SubElement(self.root, keyword+"s", attrib={'type': t})
        transforms = TransformElements()
        for k, v in sorted(rules.items(), key=lambda x:(-len(x[0]), x[0])):
            fr = unicode(k)
            to = unicode(v)
            for i in range(min(len(to), len(fr))):
                if fr[i] != to[i]:
                    before = fr[:i]
                    fr = fr[i:]
                    to = to[i:]
                    break
            else:
                continue
            for i in range(1, min(len(to), len(fr))):
                if fr[-i] != to[-i]:
                    if i > 1:
                        end = fr[1-i:]
                        fr = fr[:1-i]
                        to = to[:1-i]
                    else:
                        end = ""
                    break
            else:
                end = ""
            a = {}
            if len(before): a['before'] = before
            a['from'] = fr
            if len(end) : a['after'] = end
            a['to'] = to
            #a['test_from'] = self._readable(k)
            #a['test_to'] = self._readable(v)
            if getattr(v, 'error', False):
                a['error'] = "fail"
            transforms.addElement(**a)
        for v in transforms.asReadable():
            et.SubElement(ts, keyword, attrib=v)

    def addLayer(self, rows, modifiers, switches, extras):
        ls = et.SubElement(self.root, "layer", attrib={'modifier': modifiers})
        for r in rows:
            a = {'keys': " ".join(zip(*r)[0])}
            w = zip(*r)[1]
            if extras and any(x for x in w if int(x) != 100):
                a['widths'] = " ".join(w)
            et.SubElement(ls, "row", attrib=a)
        for s in switches:
            et.SubElement(ls, "switch", attrib={'iso': s[0], 'layer': s[1], 'display': s[2]})

    def addImport(self, path):
        i = et.SubElement(self.root, "import", attrib={'path': path})

def readable(s):
    return u"".join("\\u{:04X}".format(ord(x)) \
            if unicodedata.category(x) in ("Cf", "WS", "Mc", "Mn") else x for x in unicode(s))

class TransformElements:
    def __init__(self):
        self.elements = {}

    def addElement(self, **kw):
        test = "|".join("|".join(x) for x in sorted((k, v) for k,v in kw.items() if k != 'before' and k != 'after'))
        if test in self.elements:
            e = self.elements[test]
            count = 0
            for k in ('before', 'after'):
                if (k in kw) != (k in e):
                    break
                if k not in kw: continue
                count += self.countDiffs(kw[k], e[k])
            if count == 1:
                for k in ('before', 'after'):
                    if k not in kw: continue
                    e[k] = self.mergeTransform(e[k], kw[k])
                return
            elif count == 0:
                return
        self.elements[test] = kw

    def countDiffs(self, new, old):
        if len(new) != len(old):
            return False
        count = 0
        for i,o in enumerate(old):
            if isinstance(o, basestring):
                if o != new[i]:
                    count += 1
            elif new[i] not in o:
                count += 1
        return count

    def mergeTransform(self, old, new):
        if isinstance(old, basestring):
            old = [set(x) for x in old]
        for i, o in enumerate(old):
            if new[i] not in o:
                o.add(new[i])
        return old

    def asReadable(self):
        for v in (dict(v) for v in sorted(self.elements.values(), key=lambda x:([(-len(x[y]),x[y]) if y in x else (0, "") for y in ('from', 'before', 'after', 'to')],x))):
            for k,b in v.items():
                if k in ('before', 'after'):
                    res = u""
                    for l in b:
                        if len(l) > 1:
                            res += "[" + u"".join(readable(x) for x in sorted(l)) + "]"
                        else:
                            res += readable(list(l)[0])
                else:
                    res = readable(b)
                v[k] = res
            yield v
        

class OutputString:
    def __init__(self, toklist):
        self.str = u""
        self.error = 0
        import pdb
        for t in toklist:
            if isinstance(t, basestring):
                self.str += t
            elif isinstance(t, Token) and t.type == 'KEYWORD':
                if t.value == 'beep':
                    self.error = 1
            else:
                pdb.set_trace()

    def __unicode__(self):
        return self.str

def process_uses(p, name, *extras):
    for t in p.uses.get(name, set()):
        for r in p.allRules[t]:
            make_transform(r, p, *extras)
        process_uses(p, t, *extras)

def process_kmn(ldml, kmnfile, platform={}, reorder=False, reorderfile=None):
    with codecs.open(kmnfile, "r", encoding="utf-8-sig") as f:
        lines = "".join(f.readlines())
    p = Parser(lines, debug = (args.debug & 2), platform = platform)
    if (args.debug & 1):
        print(pformat(p.tree))
    for s in p.allStores.values():
        s.flatten()
    maps = { "" : {}, "shift" : {} }
    for r in p.allRules[p.begins['unicode']]:
        if len(r.before):
            continue
        error = False
        for rf in r.flatten(p.allStores):
            if rf.match is None: continue
            k = mapkey(rf.match)
            if k[1] not in maps:
                maps[k[1]] = {}
            maps[k[1]][k[0]] = OutputString(rf.output)
    if '&NAME' in p.allHeaders:
        ldml.setname(p.allHeaders['&NAME'].seq[0])
    else:
        ldml.setname('Unknown')
    for km in sorted(maps.keys()):
        ldml.addKeyMap(maps[km], km)

    simples = {}
    finals = {}
    backups = {}
    uses = set()
    for r in p.allRules[p.begins['unicode']]:
        make_transform(r, p, maps, simples, finals, backups)
    process_uses(p, p.begins['unicode'], maps, simples, finals, backups)
    if len(simples):
        ldml.addTransform('simple', simples)
    if reorder:
        ldml.addImport('shared/reorders.xml')
    if reorderfile:
        ldml.addImport(reorderfile)
    if len(finals):
        ldml.addTransform('final', finals)
    if len(backups):
        ldml.addTransform('backspace', backups, keyword="backspace")

def make_transform(r, p, maps, simples, finals, backups):
    if not len(r.before):
        return
    isdead = any(filter(lambda x: isinstance(x, DeadKey), r.before))
    error = False
    for rf in r.flatten(p.allStores):
        bs = []
        for b in rf.before:
            bs.extend(b)
        btxt = u"".join(bs)
        otxt = OutputString(rf.output)
        k = mapkey(rf.match)
        if k is not None:
            if k[0] == 'bksp':
                backups[btxt] = otxt
                continue
            mp = maps[k[1]]
            if k[0] not in mp:
                mp[k[0]] = unichr(DeadKey.missing)
                finals[unichr(DeadKey.missing)] = ""
                DeadKey.missing += 1
            m = mp[k[0]]
            btxt += unicode(m)
        if error:
            otxt.error = True
        if btxt == unicode(otxt) and not error:
            continue
        if isdead:
            if btxt not in simples:
                simples[btxt] = unicode(otxt)
        elif any(x not in unicode(otxt) for x in btxt): # skip reorderings
            if btxt not in finals:
                finals[btxt] = unicode(otxt)

layermap = {"default": "", "shift": "shift", "leftctrl": "ctrlL", "rightctrl": "ctrlR",
            "ctrl": "ctrl", "leftalt": "altL", "rightalt": "altR", "lefctrl-rightalt": "altR+ctrlL",
            "ctrl-alt": "alt+ctrl"}
nonoutputkeys = set(("lshift", "rshift", "shift", "lcontrol", "lctrl", "rcontrol", "rctrl",
                    "ctrl", "lmenu", "lalt", "rmenu", "ralt", "alt", "altgr", "currencies",
                    "numerals", "shifted", "upper", "lower", "symbols", "bksp", "numlock",
                    "lopt", "ropt", "opt", "enter", "space"))
sparekeyCount = 1
def process_layout(ldml, jsfile, platform = {}, extras=False):
    layertype = platform['form']
    with codecs.open(jsfile, "r", encoding="utf-8") as f:
        linfo = json.load(f)
    if layertype not in linfo:
        layertype = linfo.keys()[0]
    layers = dict((l["id"], i) for i, l in enumerate(linfo[layertype]["layer"]))
    jobs = set(["default"])
    jobsdone = set()
    while len(jobs):
        newjobs = set()
        for j in jobs:
            newjobs.update(process_layer(ldml, linfo, layertype, layers, j, extras))
            jobsdone.add(j)
        jobs = newjobs - jobsdone

def process_layer(ldml, linfo, layertype, layers, lid, extras):
    layer = linfo[layertype]["layer"][layers[lid]]
    mods = layermap.get(lid, lid)
    rows = []
    res = set()
    switches = []
    for r in layer["row"]:
        currrow = []
        rows.append(currrow)
        for k in r["key"]:
            if "id" not in k:
                continue
            kid, to = process_key(ldml, mods, k)
            longpress = []
            for sk in k.get("sk", []):
                (_, sto) = process_key(ldml, mods, sk, isSubKey=True)
                longpress.append(sto)
            if len(longpress):
                ldml.keyAddAttrs(mods, kid, {"longPress": u" ".join(longpress)})
            if "width" not in k:
                currrow.append((kid, "100"))
            else:
                v = k["width"]
                if not re.match(ur'[0-9]+$', v):
                    v = "100"
                currrow.append((kid, v))
            if "nextlayer" in k:
                res.add(k["nextlayer"])
                switches.append((kid, k["nextlayer"], k.get('text', '')))
    ldml.addLayer(rows, mods, switches, extras)
    return res

def process_key(ldml, mods, k, isSubKey=False):
    global sparekeyCount
    kid = ""
    if k["id"].startswith("K_"):
        vkey = VKey((k["id"],))
        vk = vkey.getkey()
        if "layer" in k:
            testmod = k["layer"]
        elif mods in layermap.values():
            testmod = mods
        else:
            testmod = ""
        to = ldml.mapKey(vk[0], layermap.get(testmod, testmod))
        if not isSubKey and vk[0] not in nonoutputkeys and (to == '' or testmod != mods):
            kid = "SK{:02}".format(sparekeyCount)
            sparekeyCount += 1
            ldml.addKey(mods, kid, to)
        else:
            kid = vk[0]
    elif k["id"].startswith("U_"):
        kid = k["id"].replace("_", "").lower()
        to = unichr(int(k["id"][2:], 16))
        if not isSubKey:
            ldml.addKey(mods, kid, to)
    else:
        kid = k["id"].replace("_", "").lower()
        to = k.get("text", '')
    if to != '' and to != k.get("text", to):
        ldml.addDisplay(to, k["text"])
    return (kid, to)



parser = argparse.ArgumentParser()
parser.add_argument('outfile',help="Generated LDML file")
parser.add_argument('-k','--kmn',help='Process kmn file')
parser.add_argument('-l','--layout',help='Process layout .js file')
parser.add_argument('-r','--reorder',action='store_true',help='Add reordering import')
parser.add_argument('-R','--reorderfile',help='Specifies reorder file to import, can occur with -r for standard import')
parser.add_argument('-L','--locale',default="und-Zyyy",help='Keyboard Locale identifier')
parser.add_argument('-f','--form',default='phone',help='form factor platform [phone]')
parser.add_argument('-u','--ui',default='touch',help='User Interface platform [touch]')
parser.add_argument('-O','--os',default='windows',help='Operating Systems platform [windows]')
parser.add_argument('-F','--full',action="store_true",help="Output extra stuff")
parser.add_argument('-z','--debug',type=int,default=0)
args = parser.parse_args()

ldml = LDMLKeyboard(args.locale)

platform = dict((x, getattr(args, x)) for x in ('form', 'ui', 'os'))

if args.kmn:
    process_kmn(ldml, args.kmn, platform=platform, reorder=args.reorder, reorderfile=args.reorderfile)

if args.layout:
    process_layout(ldml, args.layout, platform=platform, extras=args.full)

with codecs.open(args.outfile, "w", encoding="utf-8") as f:
    ldml.serialize_xml(f.write, doctype='<!DOCTYPE keyboard SYSTEM "../dtd/ldmlKeyboard.dtd">')

